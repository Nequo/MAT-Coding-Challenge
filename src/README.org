#+TITLE: MAT challenge backend application

* Usage
Make sure that you have docker-compose running properly as it is described in
the repository's [[https://github.com/Nequo/MAT-Coding-Challenge/blob/master/README.md][README file]] .
I used pipenv to manage the python environment. Instructions for installing are
[[https://github.com/pypa/pipenv][here]]. Run `pipenv install` from the project's main directory. This will install
all the necessary packages from  the provided Pipfile. Now you can run `pipenv
run python src/backend.py` which will run the application.
* Methodology
I was first thinking of representing the track as a set of points on a curve,
and then estimating the nearest point. I got a sample of track points by
getting all the json data for a single car for 1min40 seconds which I estimated
was the time it took for a lap to complete. I then saved the data into a csv
file that can be found at the root of this repo. I ended up dropping this path as I
learned about [[http://pointclouds.org/documentation/tutorials/kdtree_search.php][KDTrees]] but I got a nice graph of the circuit that I thought I
would include :). I used [[https://stackoverflow.com/questions/31464345/fitting-a-closed-curve-to-a-set-of-points][this]] as my source to get a visualisation. The code can
be found in the source code file track_gen.py.
#+html: <p align="center"><img src="../track.png/" /></p>

** The KDTree approach for getting a position
I then was debating using a time-sorted array of approximated coordinates
and iterate through it on each measurement to find the closest point to a
measurement. This seemed very slow so I researched a better way to do it. This
led me to learn about KDTrees which are an efficient data structure for
finding nearest neighbors to a given point from a list of coordinates. Remember that our track
coordinates were taken from a single car and hence we have a list of consecutive
points on track. By getting the index of the closest of these points to a given
car position measurement, we can estimate the position on track of a car. We
will call these indexes sectors. In addition, we have to keep track of how many
laps were done in total so we add 1 to the total number of laps for a car when
it passes sector 1. Note that restarting the backend could create a disruption
as all state is lost upon shutting down and lap numbers will be forgotten. Even
if we saved any state, if the backend was off for long enough it would become
obsolete hence why I decided to keep this as is.
** Getting the speed of a car
In order to get the speed of a car, we can calculate the distance between 2
consecutive measurements that we get for a car. I used the geopy library for
this as it provides accurate measurements when provided with latitude and
longitude coordinates. We can then divide the distance by the difference in
the times at which the measurements were taken.
